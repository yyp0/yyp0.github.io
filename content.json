{"meta":{"title":"yyp0's blog","subtitle":"","description":"业余web选手","author":"yyp0","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java类加载机制","slug":"Java类加载机制","date":"2020-05-23T14:40:23.000Z","updated":"2020-05-23T14:42:46.028Z","comments":true,"path":"2020/05/23/Java类加载机制/","link":"","permalink":"http://yoursite.com/2020/05/23/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"Java从源代码到运行经历了编译和运行的过程，编译就是将源代码编译成字节码的过程，.java 文件被编译成了 .class 文件。运行过程中，.class 文件被 Java 虚拟机解释，经历了类的加载和类的执行两个过程。以下主要阐述 Java 类加载机制。","text":"Java从源代码到运行经历了编译和运行的过程，编译就是将源代码编译成字节码的过程，.java 文件被编译成了 .class 文件。运行过程中，.class 文件被 Java 虚拟机解释，经历了类的加载和类的执行两个过程。以下主要阐述 Java 类加载机制。 类加载机制什么是类加载机制在编译阶段 .java 文件被编译成了 .class 文件，.class 文件中主要是描述类的数据。类的加载就是 Java 虚拟机把描述类的数据从 .class 文件加载到内存，并且队数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 Java 类加载机制的过程Java 类加载机制主要分为类的加载、类的连接（验证、准备、解析）、类的初始化三大过程。 类的加载 类的加载主要有三大阶段：定位 .class 文件，转换数据存储结构，生成 java.lang.Class 对象 定位 .class 文件 通过类的全限定名（包名与类名）来获取相应的 .class 文件，可获取 .class 文件的方式有：本地加载、通过网络下载 .class 文件，从 jar 包或者 war包获取、JSP 文件生成等方式 转换数据存储结构 这一步完成的是将 .class 文件中的类的静态存储结构转换成运行时在内存中方法区的数据结构 生成 java.lang.Class对象 在内存中生成一个 java.lang.Class 对象，这个对象作为方法区中这个类的数据的入口。 类的初始化 在类的连接的准备过程中，（仅仅）类的静态常量被初始化赋值（非默认值），在类的初始化阶段，类的静态变量会被初始化赋值（非默认值，在类的连接过程中，静态变量被赋值为默认值） 以下几种情况需要对类进行初始化： ​ a. 使用 new 创建对象 ​ b. 通过反射调用类的方法和对象时，如果类没有被初始化过的话，就必须对类进行初始化 ​ c. 初始化子类时，如果这个类的父类没有被初始化的话那么需要先初始化父类 ​ d. 虚拟机启动时，定义了 main() 方法的类先被初始化 ​ e. 访问类的静态方法和静态变量（非静态常量） 常见的被动引用例子： ​ a. 通过子类调用父类的静态变量和方法时，只会对父类进行初始化，子类不会被初始化 ​ b. 通过数组定义来引用类，不会触发类的初始化 ​ c. 访问类的常量时，不会初始化类（常量在类的连接的准备过程中就被初始化了）","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"文件上传小总结","slug":"文件上传小总结","date":"2020-05-15T08:11:47.000Z","updated":"2020-05-15T11:47:54.295Z","comments":true,"path":"2020/05/15/文件上传小总结/","link":"","permalink":"http://yoursite.com/2020/05/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"前端校验前端校验即客户端校验，一般在前端对文件名检验一次 123456789101112131415&lt;script&gt; var file_arr &#x3D; [&#39;jpg&#39;, &#39;png&#39;, &#39;txt&#39;]; function checkfile(filename)&#123; var pos &#x3D; filename.indexof(&#39;.&#39;); var file_ext &#x3D; filename.substr(pos+1); for(int i&#x3D;0; i&lt;arr.length; i++)&#123; if(file_arr &#x3D;&#x3D; file_ext) return true; &#125; retun false &#125;&lt;&#x2F;script&gt;&lt;form action&#x3D;&quot;login.php&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;upload&quot; onchange&#x3D;checkfile(this.value)&#x2F;&gt;&lt;&#x2F;form&gt;","text":"前端校验前端校验即客户端校验，一般在前端对文件名检验一次 123456789101112131415&lt;script&gt; var file_arr &#x3D; [&#39;jpg&#39;, &#39;png&#39;, &#39;txt&#39;]; function checkfile(filename)&#123; var pos &#x3D; filename.indexof(&#39;.&#39;); var file_ext &#x3D; filename.substr(pos+1); for(int i&#x3D;0; i&lt;arr.length; i++)&#123; if(file_arr &#x3D;&#x3D; file_ext) return true; &#125; retun false &#125;&lt;&#x2F;script&gt;&lt;form action&#x3D;&quot;login.php&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;upload&quot; onchange&#x3D;checkfile(this.value)&#x2F;&gt;&lt;&#x2F;form&gt; 这种情况下，我们可以直接在本地删除掉 onchange 事件，或者先上传一个符合条件的文件，然后再用 burp 抓包改包 后端校验后端校验，一般会校验文件的后缀，文件的 MIME，文件头，文件内容等，校验方式一般有黑名单和白名单 黑名单一般校验后缀使用黑名单的方式： 假设漏洞代码如下： 12345678910111213&lt;?php $filename &#x3D; $_FILE[&#39;file&#39;][&#39;filename&#39;] $path &#x3D; &#39;&#x2F;xxxxxx&#x2F;&#39;.$filname; $arr &#x3D; [&#39;.php&#39;, &#39;.html&#39;, &#39;.php5&#39;, &#39;php4&#39;, &#39;php2&#39;, &#39;phtml&#39;,&#39;phtm&#39;...] $file_ext &#x3D; strstr($filename, &#39;.&#39;); if(in_array($filename, $arr))&#123; die(&quot;Not allow...&quot;) &#125;else&#123; if(move_uploaded_file($_FILE[&#39;file&#39;][&#39;tmp_name&#39;], $path))&#123; echo &quot;Upload success...&quot; &#125; &#125;?&gt; 绕过方法： 大小写绕过 上面的代码没有对大小写进行检验，当我们上传 1.PHP 时可以上传成功 修补： 1$file_ext &#x3D; strtolower(strstr($filename, &#39;.&#39;)); 将文件后置转换成小写 空格绕过 可以看到上面的代码，没有去除原文件后缀的空格，所以我们可以上传文件名为”1.php “进行绕过，这是因为php 解析文件名的时候会自动去掉后面的空格 修补： 1$file_ext &#x3D; trim($file_ext); ‘.’ 绕过 漏洞代码没有对文件后缀的 . 进行处理，在 windows 系统中，会自动去除文件后缀中的点，所以我们可以上传文件名为 “1.php.”，后端取出的文件名就为 “.php.”，即可绕过 修补： 12345678910$len &#x3D; strlen($file_ext);$ext &#x3D; &#39;&#39;;for($i&#x3D;1; $i&lt;$len; $i++)&#123; if($file_ext[i] !&#x3D; &#39;.&#39;)&#123; $ext +&#x3D; $file_ext[i]; &#125;else&#123; break; &#125;&#125;$file_ext &#x3D; $ext; 删除文件后缀的所有点 ::$DATA 绕过 同样在 windows 下，创建文件时如果后缀中有 ::$DATA，就会直接删掉这个字段 所以我们可以上传文件绕过黑名单检测，上传文件：1.php::$DATA 修补： 123if(preg_match(&#x2F;::DATA&#x2F;i, $filename))&#123; $file_ext &#x3D; substr($file_ext,0,str_len($file_ext)-6);&#125; 寻找漏网之鱼 fuzz 没被黑名单过滤的文件，比如上传 .htaccess 文件 1&lt;FilesMatch &quot;sec.jpg&quot;&gt; SetHandler application&#x2F;x-httpd-php &lt;&#x2F;FilesMatch&gt; 双写绕过 有些代码过滤逻辑是这样的： 12$pattern &#x3D; &quot;&#x2F;php|htm|htaccess...&#x2F;i&quot;$file_ext &#x3D; preg_replace($pattern, &#39;&#39;, $file_ext); 这时候上传文件 1.pphphp 即可绕过 白名单 对 MIME 的检测一般用的是白名单的方式，比如 12345if($_FILE[&#39;file&#39;][&#39;type&#39;]&#x3D;&#x3D;&#39;image&#x2F;jpeg&#39; || $_FILE[&#39;file&#39;][&#39;type&#39;]&#x3D;&#x3D;&#39;image&#x2F;png&#39;)&#123; ....&#125;else&#123; die(&quot;Type not allowed....&quot;);&#125; 绕过这种只要 burp 抓包改掉 content-type 即可，由于用户发过来的包中 content-type 并不真实，所以，尽量不要依靠这种方式做检验 自定义文件上传的路径 12345678910$upfodler &#x3D; $_GET[&#39;fodler&#39;];$file_name &#x3D; $_FILE[&#39;file&#39;][&#39;name&#39;];$file_ext &#x3D; explode($file_name, &#39;.&#39;)[1];$arr &#x3D; array(&#39;png&#39;, &#39;jpg&#39;, &#39;gif&#39;);if(in_array($file_ext, $arr))&#123; $path &#x3D; $upfodler.$file_name; if(move_uploaded_file($_FILE[&#39;file&#39;][&#39;tmp_name&#39;], $path))&#123; echo &quot;upload success...&quot; &#125;&#125; 由于这里得到文件最终路劲的方法是直接拼接，给了我们进行 00 截断的可能性。 利用手段： 123folder &#x3D; &#x2F;var&#x2F;www&#x2F;html&#x2F;1.php%00上传的文件名为：1.jpg 所以，1.jpg可以绕过后缀的检测，而 move_uploaded_file 时，可以将临时文件的内容写到 1.php，达到了绕过的功能 文件幻数和文件信息检测 一般来说用图片马即可绕过常见的 getimagesize 和 phpexif 函数 制作图片马： 1copy normal.jpg &#x2F;b + shell.php &#x2F;a webshell.jpg 图片渲染一次渲染：只要在图片的空白处注入代码即可 二次渲染：对比 GD库处理后的图片，在处理前后没有发生变化的地方注入代码 条件竞争比如如下代码： 1234567891011121314151617181920if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload &#x3D; true; &#125;else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg &#x3D; &#39;上传出错！&#39;; &#125;&#125; 先 move_uploaded_file 且move_uploaded_file时还没有对文件重命名，再 unlink，给了我们时间去访问 webshell 文件上传的两要素：1. 上传点 2. 文件存储路径，如果文件存储路径不存在的话，那么就找这个文件在网页中的输出点","categories":[],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}],"categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}